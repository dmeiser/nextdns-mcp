name: Build and Push Docker Image

on:
  # Trigger after successful test workflows on main branch
  workflow_run:
    workflows: ["Unit Tests", "E2E MCP Gateway"]
    types:
      - completed
    branches:
      - main
  
  # Trigger on version tags (v1.0.0, v2.0.0, etc.)
  push:
    tags:
      - 'v*.*.*'           # Stable releases: v1.0.0
      - 'v*.*.*-alpha.*'   # Alpha releases: v1.0.0-alpha.1
      - 'v*.*.*-beta.*'    # Beta releases: v1.0.0-beta.1
      - 'v*.*.*-rc.*'      # Release candidates: v1.0.0-rc.1
  
  # Allow manual trigger
  workflow_dispatch:

permissions:
  contents: read
  packages: write  # Required to push to ghcr.io

jobs:
  docker-publish:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    
    # Only run on main branch (after merge), tags, or manual dispatch - never on PRs
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main') ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Check for duplicate runs and wait for all workflows
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/github-script@v7
        with:
          script: |
            const requiredWorkflows = ['Unit Tests', 'E2E MCP Gateway'];
            const currentWorkflow = context.payload.workflow_run.name;
            const headSha = context.payload.workflow_run.head_sha;
            
            console.log(`Triggered by: ${currentWorkflow}`);
            console.log(`Checking SHA: ${headSha}`);
            
            // Check if there's already a running Docker publish workflow for this SHA
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'docker-publish.yml',
              head_sha: headSha,
              per_page: 10
            });
            
            // Filter for runs that are currently running (excluding this one)
            const otherRunningBuilds = runs.workflow_runs.filter(run => 
              run.id !== context.runId && 
              run.status === 'in_progress'
            );
            
            if (otherRunningBuilds.length > 0) {
              console.log(`Another Docker publish workflow is already running (${otherRunningBuilds[0].id}). Exiting to avoid duplicate build.`);
              core.notice('Skipping duplicate Docker publish workflow - another instance is already running');
              process.exit(0);
            }
            
            // Initial check: verify current workflow status and determine what we need to wait for
            const { data: initialRuns } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: headSha,
              per_page: 100
            });
            
            const workflowStatus = {};
            for (const workflow of requiredWorkflows) {
              const run = initialRuns.workflow_runs.find(r => r.name === workflow);
              if (run) {
                workflowStatus[workflow] = {
                  status: run.status,
                  conclusion: run.conclusion
                };
              }
            }
            
            console.log('Initial workflow status:', JSON.stringify(workflowStatus, null, 2));
            
            // Early exit: if all workflows are already complete and successful, skip polling
            let allComplete = requiredWorkflows.every(workflow => {
              const status = workflowStatus[workflow];
              return status && status.status === 'completed' && status.conclusion === 'success';
            });
            
            if (allComplete) {
              console.log('âœ… All required workflows already completed successfully - skipping wait loop');
            } else {
              // Wait for remaining workflows with exponential backoff
              let attempts = 0;
              let waitSeconds = 10; // Start with 10 seconds
              const maxWaitSeconds = 60; // Cap at 60 seconds
              const maxAttempts = 30; // ~20 minutes max (with exponential backoff: 10+20+40+60*27)
              
              while (!allComplete && attempts < maxAttempts) {
                const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  head_sha: headSha,
                  per_page: 100
                });
                
                const workflowStatus = {};
                for (const workflow of requiredWorkflows) {
                  const run = workflowRuns.workflow_runs.find(r => r.name === workflow);
                  if (run) {
                    workflowStatus[workflow] = {
                      status: run.status,
                      conclusion: run.conclusion
                    };
                  }
                }
                
                console.log('Workflow status:', JSON.stringify(workflowStatus, null, 2));
                
                // Check if all required workflows are complete and successful
                allComplete = requiredWorkflows.every(workflow => {
                  const status = workflowStatus[workflow];
                  return status && status.status === 'completed' && status.conclusion === 'success';
                });
                
                if (!allComplete) {
                  // Check for failures
                  const hasFailure = requiredWorkflows.some(workflow => {
                    const status = workflowStatus[workflow];
                    return status && status.status === 'completed' && status.conclusion !== 'success';
                  });
                  
                  if (hasFailure) {
                    core.setFailed('One or more required workflows failed');
                    return;
                  }
                  
                  console.log(`Waiting for workflows to complete... (attempt ${attempts + 1}/${maxAttempts}, next check in ${waitSeconds}s)`);
                  await new Promise(resolve => setTimeout(resolve, waitSeconds * 1000));
                  attempts++;
                  
                  // Exponential backoff: double wait time until max
                  waitSeconds = Math.min(waitSeconds * 2, maxWaitSeconds);
                }
              }
            }
            
            if (!allComplete) {
              core.setFailed('Timeout waiting for required workflows to complete');
            } else {
              console.log('âœ… All required workflows completed successfully');
            }
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # For workflow_run events, checkout the commit that triggered the workflow
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ secrets.DOCKERHUB_USERNAME }}/nextdns-mcp
            ghcr.io/${{ github.repository }}
          tags: |
            # Tag with 'latest' for main branch (stable releases only)
            type=raw,value=latest,enable=${{ github.ref_type == 'branch' && github.ref_name == 'main' }}
            # Tag with commit SHA
            type=sha,prefix=,format=short
            # Semantic version tags from git tags (v1.0.0 -> 1.0.0, 1.0, 1)
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}},enable=${{ !contains(github.ref, '-') }}
            # Pre-release tags (alpha, beta, rc) - tag with full version only
            type=semver,pattern={{version}},enable=${{ contains(github.ref, '-') }}
            # Tag with the git ref (for manual identification)
            type=ref,event=tag
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          build-args: |
            BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}
            REVISION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.revision'] }}
      
      - name: Generate image summary
        run: |
          echo "## ðŸ³ Docker Images Published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Docker Hub" >> $GITHUB_STEP_SUMMARY
          echo "**Registry:** docker.io/${{ secrets.DOCKERHUB_USERNAME }}/nextdns-mcp" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "docker pull ${{ secrets.DOCKERHUB_USERNAME }}/nextdns-mcp:latest" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### GitHub Container Registry" >> $GITHUB_STEP_SUMMARY
          echo "**Registry:** ghcr.io/${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "docker pull ghcr.io/${{ github.repository }}:latest" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tags Applied:** latest, commit SHA, v2.0.0, v2.0, v2" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Platforms:** linux/amd64, linux/arm64" >> $GITHUB_STEP_SUMMARY
